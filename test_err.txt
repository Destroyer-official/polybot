============================= test session starts =============================
platform win32 -- Python 3.14.2, pytest-9.0.2, pluggy-1.6.0
rootdir: C:\Users\shant\Desktop\polybot
plugins: anyio-4.12.0, hypothesis-6.148.8, asyncio-1.3.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 1 item

tests\test_main_orchestrator_properties.py F                             [100%]

================================== FAILURES ===================================
________________ TestGasPriceHalt.test_gas_price_halt_property ________________

self = <tests.test_main_orchestrator_properties.TestGasPriceHalt object at 0x000001E619FE2FD0>
mock_config = <Mock spec='Config' id='2087790549312'>
mock_web3 = <Mock id='2087790549984'>

    @pytest.mark.asyncio
>   @given(
            
        gas_price_gwei=st.integers(min_value=1, max_value=2000)
    )

tests\test_main_orchestrator_properties.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = ()
kwargs = {'gas_price_gwei': 1, 'mock_config': <Mock spec='Config' id='2087790549312'>, 'mock_web3': <Mock id='2087790549984'>, 'self': <tests.test_main_orchestrator_properties.TestGasPriceHalt object at 0x000001E619FE2FD0>}
coro = <coroutine object TestGasPriceHalt.test_gas_price_halt_property at 0x000001E61A03E710>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
>       runner.run(coro, context=context)

D:\program_software\Python314\Lib\site-packages\pytest_asyncio\plugin.py:716: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <asyncio.runners.Runner object at 0x000001E61A03A660>
coro = <coroutine object TestGasPriceHalt.test_gas_price_halt_property at 0x000001E61A03E710>

    def run(self, coro, *, context=None):
        """Run code in the embedded event loop."""
        if events._get_running_loop() is not None:
            # fail fast with short traceback
            raise RuntimeError(
                "Runner.run() cannot be called from a running event loop")
    
        self._lazy_init()
    
        if not coroutines.iscoroutine(coro):
            if inspect.isawaitable(coro):
                async def _wrap_awaitable(awaitable):
                    return await awaitable
    
                coro = _wrap_awaitable(coro)
            else:
                raise TypeError('An asyncio.Future, a coroutine or an '
                                'awaitable is required')
    
        if context is None:
            context = self._context
    
        task = self._loop.create_task(coro, context=context)
    
        if (threading.current_thread() is threading.main_thread()
            and signal.getsignal(signal.SIGINT) is signal.default_int_handler
        ):
            sigint_handler = functools.partial(self._on_sigint, main_task=task)
            try:
                signal.signal(signal.SIGINT, sigint_handler)
            except ValueError:
                # `signal.signal` may throw if `threading.main_thread` does
                # not support signals (e.g. embedded interpreter with signals
                # not registered - see gh-91880)
                sigint_handler = None
        else:
            sigint_handler = None
    
        self._interrupt_count = 0
        try:
>           return self._loop.run_until_complete(task)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

D:\program_software\Python314\Lib\asyncio\runners.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ProactorEventLoop running=False closed=False debug=False>
future = <Task finished name='Task-2' coro=<TestGasPriceHalt.test_gas_price_halt_property() done, defined at C:\Users\shant\Des...\Users\\\\shant\\\\Desktop\\\\polybot\\\\src\\\\main_orchestrator.py'> does not have the attribute 'TradeStatistics'")>

    def run_until_complete(self, future):
        """Run until the Future is done.
    
        If the argument is a coroutine, it is wrapped in a Task.
    
        WARNING: It would be disastrous to call run_until_complete()
        with the same coroutine twice -- it would wrap it in two
        different Tasks and that can't be good.
    
        Return the Future's result, or raise its exception.
        """
        self._check_closed()
        self._check_running()
    
        new_task = not futures.isfuture(future)
        future = tasks.ensure_future(future, loop=self)
        if new_task:
            # An exception is raised if the future didn't complete, so there
            # is no need to log the "destroy pending task" message
            future._log_destroy_pending = False
    
        future.add_done_callback(_run_until_complete_cb)
        try:
            self.run_forever()
        except:
            if new_task and future.done() and not future.cancelled():
                # The coroutine raised a BaseException. Consume the exception
                # to not log a warning, the caller doesn't have access to the
                # local task.
                future.exception()
            raise
        finally:
            future.remove_done_callback(_run_until_complete_cb)
        if not future.done():
            raise RuntimeError('Event loop stopped before Future completed.')
    
>       return future.result()
               ^^^^^^^^^^^^^^^

D:\program_software\Python314\Lib\asyncio\base_events.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_main_orchestrator_properties.TestGasPriceHalt object at 0x000001E619FE2FD0>
gas_price_gwei = 1, mock_config = <Mock spec='Config' id='2087790549312'>
mock_web3 = <Mock id='2087790549984'>

    @pytest.mark.asyncio
    @given(
        gas_price_gwei=st.integers(min_value=1, max_value=2000)
    )
    @settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])
    async def test_gas_price_halt_property(self, gas_price_gwei, mock_config, mock_web3):
        """
        Property: Gas price monitoring should halt trading when gas > 800 gwei.
    
        For any gas price:
        - If gas_price > 800 gwei: _check_gas_price() returns False (halt trading)
        - If gas_price <= 800 gwei: _check_gas_price() returns True (allow trading)
        """
        # Setup
        mock_web3.eth.gas_price = gas_price_gwei * 10**9  # Convert to wei
    
>       with _orchestrator_patches(mock_web3) as mocks:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_main_orchestrator_properties.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <contextlib._GeneratorContextManager object at 0x000001E61A0AB8C0>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
                   ^^^^^^^^^^^^^^

D:\program_software\Python314\Lib\contextlib.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

mock_web3 = <Mock id='2087790549984'>

    @contextlib.contextmanager
    def _orchestrator_patches(mock_web3):
        """
        Apply all patches needed to safely instantiate MainOrchestrator.
        Uses ExitStack to avoid Python's static nesting limit.
    
        Yields a dict of named mocks that tests may need (fund_manager, circuit_breaker).
        """
        patches = {
            'web3': patch('src.main_orchestrator.Web3', return_value=mock_web3),
            'clob': patch('src.main_orchestrator.ClobClient'),
            'tx_mgr': patch('src.main_orchestrator.TransactionManager'),
            'pos_merger': patch('src.main_orchestrator.PositionMerger'),
            'order_mgr': patch('src.main_orchestrator.OrderManager'),
            'safety': patch('src.main_orchestrator.AISafetyGuard'),
            'fund_mgr': patch('src.main_orchestrator.FundManager'),
            'internal_arb': patch('src.main_orchestrator.InternalArbitrageEngine'),
            'cross_arb': patch('src.main_orchestrator.CrossPlatformArbitrageEngine'),
            'latency_arb': patch('src.main_orchestrator.LatencyArbitrageEngine'),
            'res_farming': patch('src.main_orchestrator.ResolutionFarmingEngine'),
            'monitoring': patch('src.main_orchestrator.MonitoringSystem'),
            'trade_db': patch('src.main_orchestrator.TradeHistoryDB'),
            'trade_stats': patch('src.main_orchestrator.TradeStatistics'),
            'dashboard': patch('src.main_orchestrator.StatusDashboard'),
            'market_parser': patch('src.main_orchestrator.MarketParser'),
            'circuit_breaker': patch('src.main_orchestrator.CircuitBreaker'),
            'wallet_verify': patch('src.wallet_verifier.WalletVerifier.verify_wallet_address', return_value=True),
            'wallet_detect': patch('src.wallet_type_detector.WalletTypeDetector'),
        }
        with contextlib.ExitStack() as stack:
>           mocks = {name: stack.enter_context(p) for name, p in patches.items()}
                           ^^^^^^^^^^^^^^^^^^^^^^

tests\test_main_orchestrator_properties.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <contextlib.ExitStack object at 0x000001E61C248B50>
cm = <unittest.mock._patch object at 0x000001E61A0CAF90>

    def enter_context(self, cm):
        """Enters the supplied context manager.
    
        If successful, also pushes its __exit__ method as a callback and
        returns the result of the __enter__ method.
        """
        # We look up the special methods on the type to match the with
        # statement.
        cls = type(cm)
        try:
            _enter = cls.__enter__
            _exit = cls.__exit__
        except AttributeError:
            raise TypeError(f"'{cls.__module__}.{cls.__qualname__}' object does "
                            f"not support the context manager protocol") from None
>       result = _enter(cm)
                 ^^^^^^^^^^

D:\program_software\Python314\Lib\contextlib.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001E61A0CAF90>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
>       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

D:\program_software\Python314\Lib\unittest\mock.py:1503: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001E61A0CAF90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.main_orchestrator' from 'C:\\Users\\shant\\Desktop\\polybot\\src\\main_orchestrator.py'> does not have the attribute 'TradeStatistics'
E           Falsifying example: test_gas_price_halt_property(
E               self=<tests.test_main_orchestrator_properties.TestGasPriceHalt object at 0x000001E619FE2FD0>,
E               mock_config=Config(private_key='0x1111111111111111111111111111111111111111111111111111111111111111',
E                wallet_address='0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1',
E                polygon_rpc_url='https://polygon-rpc.com',
E                backup_rpc_urls=[],
E                polymarket_api_url='https://clob.polymarket.com',
E                kalshi_api_key=None,
E                nvidia_api_key='test_key',
E                usdc_address='0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',
E                ctf_exchange_address='0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E',
E                conditional_token_address='0x4D97DCd97eC945f40cF65F87097ACe5EA0476045',
E                stake_amount=Decimal('10.0'),
E                min_profit_threshold=Decimal('0.005'),
E                max_position_size=Decimal('5.0'),
E                min_position_size=Decimal('0.1'),
E                max_pending_tx=5,
E                max_gas_price_gwei=800,
E                circuit_breaker_threshold=10,
E                min_balance=Decimal('50.0'),
E                target_balance=Decimal('100.0'),
E                withdraw_limit=Decimal('500.0'),
E                cloudwatch_log_group='/test',
E                sns_alert_topic='',
E                prometheus_port=9090,
E                dry_run=False,
E                scan_interval_seconds=2,
E                heartbeat_interval_seconds=60,
E                chain_id=137,
E                flash_crash_drop_threshold=,
E                flash_crash_lookback_seconds=,
E                flash_crash_trade_size=,
E                flash_crash_take_profit=,
E                flash_crash_stop_loss=),
E               mock_web3=,
E               gas_price_gwei=1,
E           )

D:\program_software\Python314\Lib\unittest\mock.py:1473: AttributeError
============================== warnings summary ===============================
D:\program_software\Python314\Lib\site-packages\websockets\legacy\__init__.py:6
  D:\program_software\Python314\Lib\site-packages\websockets\legacy\__init__.py:6: DeprecationWarning: websockets.legacy is deprecated; see https://websockets.readthedocs.io/en/stable/howto/upgrade.html for upgrade instructions
    warnings.warn(  # deprecated in 14.0 - 2024-11-09

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/test_main_orchestrator_properties.py::TestGasPriceHalt::test_gas_price_halt_property
======================== 1 failed, 1 warning in 3.79s =========================
